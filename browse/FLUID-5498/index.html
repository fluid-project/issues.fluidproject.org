<!DOCTYPE html>
<html lang="en" dir="ltr" data-color-scheme="light">
    <head>
        <title> FLUID-5498  | Fluid Project Issues Archive</title>

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta content="width=device-width, initial-scale=1.0" name="viewport">
        <meta name="description" content="Archive of Fluid Project issues from the JIRA issue tracker">
        <meta property="og:title" content=" FLUID-5498 |  Fluid Project Issues Archive">
        <meta property="og:description" content="Archive of Fluid Project issues">
        <meta property="og:locale" content="en">
        <meta property="og:type" content="website">
        <meta property="og:url" content="https://issues.fluidproject.org/browse/FLUID-5498/">
        <link rel="canonical" href="https://issues.fluidproject.org/browse/FLUID-5498/">


        <link rel="stylesheet" href="/assets/styles/style.css">

        
<script type="module" src="/assets/scripts/relative-time/bundle.js"></script>

    </head>
    <body class="page-issue">
        <header class="mt-3">
            <a class="skip-link" href="#main">Skip to Content</a>
            <nav aria-label="main menu">
                <menu>
                    <li><a rel="home" href="/">Home</a></li>
                    <li><a href="/search/">Search</a></li>
                </menu>
            </nav>
            
        <nav aria-label="breadcrumbs">
            <ol>
                <li><a rel="home" href="/">Home</a></li>
                <li><a href="/projects/FLUID" data-pagefind-filter="project">Fluid Infusion</a></li>
                <li><a href="/browse/FLUID-5498/">FLUID-5498</a></li>
            </ol>
        </nav>
        <h1>FLUID-5498: Apply "transaction globbing" for any manual changes triggered as part of a change process</h1>

        </header>
        <main id="main">
            
    <div id="content" class="content with-sidebar">
        <div class="spacing-y-1 bg-default">
            <h2>Metadata</h2>
            <dl>
                <div>
                    <dt>Source</dt>
                    <dd><a href="https://fluidproject.atlassian.net/browse/FLUID-5498">FLUID-5498</a></dd>
                </div>
                <div>
                    <dt>Type</dt>
                    <dd>
                        <a href="/projects/FLUID/?type=Improvement">Improvement</a>
                    </dd>
                </div>
                <div>
                    <dt>Priority</dt>
                    <dd>Major</dd>
                </div>
                <div>
                    <dt>Status</dt>
                    <dd>Open</dd>
                </div>
                <div>
                    <dt>Resolution</dt>
                    <dd>
                            N/A
                        
                    </dd>
                </div>
                <div>
                    <dt>Assignee</dt>
                    <dd>Antranig Basman</dd>
                </div>
                <div>
                    <dt>Reporter</dt>
                    <dd>
                        <a href="/projects/FLUID/?reporter=Antranig%20Basman">Antranig Basman</a>
                    </dd>
                </div>
                <div>
                    <dt>Created</dt>
                    <dd><relative-time datetime="2014-08-21T08:32:51.649-0400" prefix="">2014-08-21T08:32:51.649-0400</relative-time></dd>
                </div>
                <div>
                    <dt>Updated</dt>
                    <dd><relative-time datetime="2020-07-30T07:51:59.432-0400" prefix="">2020-07-30T07:51:59.432-0400</relative-time></dd>
                </div>
                <div>
                    <dt>Versions</dt>
                    <dd>
                        
                        N/A
                        
                    </dd>
                </div>
                <div>
                    <dt>Fixed Versions</dt>
                    <dd>
                        
                        N/A
                        
                    </dd>
                </div>
                <div>
                    <dt>Component</dt>
                    <dd>
                        
                        <ol role="list">
                            
                            <li>Data Binder</li>
                            
                        </ol>
                        
                    </dd>
                </div>
            </dl>
        </div>

        <div>
            <div class="spacing-y-1">
                <h2>Description</h2>
                <p>A feature that might be helpful, but will require some thought, is to apply "transaction globbing" to enlist a change made by a listener in reaction to a change process. The current metadata resourceInputPanel.js contains the following function:</p>
<pre><code class="hljs language-java">gpii.metadata.baseResourceInputPanel.updateModel = function (that, value, path, index, root) {
        <span class="hljs-type">var</span> <span class="hljs-variable">changePath</span> <span class="hljs-operator">=</span> [root, index].concat(path);
        that.applier.change(changePath, value);
    };
</code></pre>
<p>This applies a form of "manual model relay" to deal with the fact that relay is coming from one of a number of dynamically generated components. It would be better to express this via configuration, but it is probably not currently possible to express relay to dynamic paths.</p>
<p>The effect of this is to kick off a second transaction in the target components - whilst the first transaction has just concluded and is in the process of notifying its listeners (including this one). This made the issue <a href="/browse/FLUID-5497/">FLUID-5497</a> somewhat harder to debug, although if this feature were implemented, that bug would still have had a damaging though slightly milder effect.</p>
<p>One possible approach might be to automatically enlist any user in any transaction which is underway in their own applier, or anywhere on their current call stack - or at least provide a straightforward means for them to supply an annotation wishing that they wish to be enlisted. The effects of this might be awkward, however, and it might be best to maintain transactions as "isolated" from the user's (that is, the materialiser's) point of view. The best next step might be to improve our handling of dynamic components and dynamic relays so that manual relay of this kind isn't necessary.</p>

            </div>
            
            
            
            
            <div class="spacing-y-1">
                <h2>Comments</h2>
                <ul class="spacing-y-2" role="list">
                    
                    <li id="comment-25404">
                        <p class="mb-0"><b>Antranig Basman</b> <i>commented <relative-time datetime="2014-08-22T15:01:32.493-0400">2014-08-22T15:01:32.493-0400</relative-time></i></p>
                        <p>A further use case appeared almost immediately. As part of the "feedback" tool, there is a requirement to operate a model constraint that is equivalent to that that governs "radio buttons" in a traditional UI - when one element is activated, any (or all) other activated element should be deactivated. This is not possible to express using any form of model relay rule, since it relies on a stateful relationship to the stream of changes. The best we could do currently is to create some new form of element, for which we lack a name - a kind of "constraint box" that interacts with a transaction and guides the evolution of state within it in a stateful way. </p>
<p>However, given the current framework we lack even the capability of doing that - since it is currently not possible to even easily discover the existence of any transactions which are active with respect to the current models. The only place it is exposed is in a private stack frame directly above that of the original external trigger of the "initial change" in the transaction. In theory one could grub about in the instantiator's transaction records, but we really need to expose a proper API for this - at least a kind of semi-user-level API such as "applier.beginTransaction" with no arguments, which will either start a fresh transaction or enlist in a current one. </p>
<p>After that, we have the problem of how to express constraints such as the "radio button constraint" in some form of reasonable declarative dialect. This problem is related to the <a href="/browse/FLUID-5337/">FLUID-5337</a> "pseudoinverse" problem but is unfortunately more serious. <a href="/browse/FLUID-5337/">FLUID-5337</a> can be implemented without any new kinds of model citizens or configuration - it just requires the inhabitants to "buy into" the idea that the existing model state will be used to "break ties" in the case there are multiple possible inverse values that could result from running a transform backwards. Unfortunately the "radio button constraint" requires explicit interaction with the history of the model. Or even just a suitable arena to express the code like the following:</p>
<pre><code class="hljs language-java">modelListeners: {
                        <span class="hljs-string">"isActive"</span>: [{
                            listener: <span class="hljs-string">"{feedback}.applier.change"</span>,
                            args: [<span class="hljs-string">"mismatch"</span>, <span class="hljs-string">"{change}.value"</span>]
                        }, {
</code></pre>
<p>in this case, no such inspection is even required, and simply the headline functionality for this JIRA would be sufficient. If we automatically glob, and apply consistent semantics for "oldValue" (that is, value before transaction start) and "newValue", we could do as well as we might in expressing such rules compactly - especially if we just house them in a dedicated component. </p>

                    </li>
                    
                    <li id="comment-25405">
                        <p class="mb-0"><b>Antranig Basman</b> <i>commented <relative-time datetime="2015-01-09T16:31:12.971-0500">2015-01-09T16:31:12.971-0500</relative-time></i></p>
                        <blockquote>
<p>Note that we discovered this constraint can be expressed quite straightforwardly on the other side of an "arrayToSetMembership" transform</p>
</blockquote>
<p>"quite straightforwardly" my foot. The solution whilst it is quite simple takes a while to reconstruct, especially as regards what the "other side" actually is. Here is the comment duplicated from <a href="/browse/FLUID-5517/">FLUID-5517</a> which explains this:</p>
<p>Note - the "proper" solution to this problem (or rather, the only one we can implement without stateful relay rules) is simple-seeming but rather obscure - it was explained in IRC at <a href="https://botbot.me/freenode/fluid-work/2014-08-25/?msg=20363141&page=2">https://botbot.me/freenode/fluid-work/2014-08-25/?msg=20363141&amp;page=2</a></p>
<p>The idea is to tackle the issue at the point of initial data binding - the UI action of selecting, say, the "match" button is not bound to the boolean end of the relay, but the array and - and the binding has the effect, say, of writing the entire array ["match"] to the so-called "inTransit.opinion" (this needs to be renamed) - rather than writing to the boolean end of the relay.</p>

                    </li>
                    
                    <li id="comment-25406">
                        <p class="mb-0"><b>Antranig Basman</b> <i>commented <relative-time datetime="2015-01-26T09:27:43.843-0500">2015-01-26T09:27:43.843-0500</relative-time></i></p>
                        <p>The headline behaviour asked for in this JIRA doesn't actually make any sense. By definition, if we are in a user listener reacting to a model change, the transaction governing it must already have concluded - we couldn't possibly "glob" to it since it must already have been cleaned up. The behaviour nonetheless is confusing - if there are multiple listeners listening to the change, all wanting to trigger further changes, the model state reported in oldValue etc. will be long gone - the first listener to react will have already caused a further change. We need to continue to discourage triggering of changes from listeners in favour of relay semantics.</p>

                    </li>
                    
                    <li id="comment-25407">
                        <p class="mb-0"><b>Antranig Basman</b> <i>commented <relative-time datetime="2020-07-30T07:51:59.432-0400">2020-07-30T07:51:59.432-0400</relative-time></i></p>
                        <p>Note that the previous comment of 26 Jan 2015 was entered at a time of maximal misunderstanding of how the current system works. The existing transaction has <strong>not</strong> been concluded during the notification of model listeners, and has not even begun to enter its "postCommit" stage. More modern comments on <a href="/browse/FLUID-6536/">FLUID-6536</a> suggest that we should continue with this model, and rather than "discouraging triggering of changes" in a reactionary way we should unify the semantics of relay rules and listeners, making it easier to write stateful relay rules as well as making it possible to enlist multiple listeners into an (existing) transaction.</p>

                    </li>
                    
                </ul>
            </div>
            
        </div>
    </div>

        </main>
        <footer>
            
<nav aria-labelledby="pagination">
    <h2 class="visually-hidden">pagination</h2>
    <p class="flex">
        
        
        <a class="mx-1" href="/browse/FLUID-5497/"><span class="aria-hidden">←</span> Previous: FLUID-5497</a>
        <a class="mx-1" href="/browse/FLUID-5499/">Next: FLUID-5499 <span class="aria-hidden">→</span></a>
    </p>
</nav>

        </footer>
    </body>
</html>